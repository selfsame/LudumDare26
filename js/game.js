// Generated by CoffeeScript 1.3.1
(function() {
  var Entity, Player, Sentient,
    __indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; };

  Entity = window.entities.Entity;

  Sentient = window.entities.Sentient;

  Player = window.entities.Player;

  $(window).ready(function() {
    window.game = {
      box2Dworld: 0,
      scale: 30,
      current_level: 0,
      current_level_background: 0,
      current_level_style: 0,
      current_level__background_style: 0,
      game_area_position: [0, 0],
      debugdraw: 0,
      player: 0,
      game_w: 800,
      game_h: 600,
      max_velocity: 10,
      max_walk: 7,
      min: 'max',
      backgrounds: {
        'background01.html': ['level01.html'],
        'empty.html': ['level02.html']
      },
      init: function() {
        $(window).keydown(function(e) {
          console.log(e.keyCode);
          if (window.game.player) {
            return window.game.player.keydown(e);
          }
        });
        $(window).keyup(function(e) {
          if (window.game.player) {
            return window.game.player.keyup(e);
          }
        });
        return $(window).mousedown(function(e) {
          var x, y;
          x = e.clientX - window.game.game_area_position[0];
          x += window.game.player.x * window.game.scale - window.game.game_w / 2;
          x = x / window.game.scale;
          y = e.clientY - window.game.game_area_position[1];
          y += window.game.player.y * window.game.scale - window.game.game_h / 2;
          y = y / window.game.scale;
          console.log(x, y);
          return window.game.getBodyAtPoint(x, y);
        });
      },
      swap_resources: function() {
        var b, child, ent, r, st, _i, _j, _len, _len1, _ref, _ref1, _results;
        _ref = $('#game_level img, #background img, #game_entities img');
        for (_i = 0, _len = _ref.length; _i < _len; _i++) {
          child = _ref[_i];
          st = $(child).attr('src');
          st = st.split('/');
          st = st[st.length - 1];
          $(child).attr('src', './img/' + this.min + '/' + st);
        }
        $('#player .anim').css('background-image', 'url(./img/' + this.min + '/sheet.png )');
        _ref1 = $('#game_level, #background, #game_entities').find('*');
        _results = [];
        for (_j = 0, _len1 = _ref1.length; _j < _len1; _j++) {
          ent = _ref1[_j];
          b = $(ent).css('border-image');
          if (b !== 'none' && b !== '') {
            console.log(b);
            b = b.split('(')[1];
            b = b.split(')');
            r = b[b.length - 1];
            b = b[0];
            b = b.split('/');
            b = b[b.length - 1];
            _results.push($(ent).css('border-image', 'url(./img/' + this.min + '/' + b + ') ' + r));
          } else {
            _results.push(void 0);
          }
        }
        return _results;
      },
      load_level: function(name) {
        var bg, g_o, key;
        g_o = $('#game_level').offset();
        this.game_area_position = [g_o.left, g_o.top];
        this.static_objects = [];
        this.dynamic_objects = [];
        $('#game_entities').html('');
        $('#background').html('');
        this.current_level = name;
        bg = 'empty.html';
        for (key in this.backgrounds) {
          if (__indexOf.call(this.backgrounds[key], name) >= 0) {
            bg = key;
          }
        }
        return $.get('./levels/' + bg, function(data) {
          var div, style, temp, _i, _len, _ref;
          temp = $('<div></div>');
          temp.html(data);
          if (this.current_level_background_style) {
            this.current_level_background_style.detach();
            this.current_level_background_style = 0;
          }
          style = temp.children('style');
          $('head').append(style);
          this.current_level_background_style = style;
          $('#background').html('');
          window.t = temp;
          _ref = temp.children('div, img');
          for (_i = 0, _len = _ref.length; _i < _len; _i++) {
            div = _ref[_i];
            $('#background').append($(div));
          }
          return $.get('./levels/' + name, function(data) {
            var div, _j, _len1, _ref1;
            temp = $('<div></div>');
            temp.html(data);
            if (this.current_level_style) {
              this.current_level_style.detach();
              this.current_level_style = 0;
            }
            style = temp.children('style');
            $('head').append(style);
            this.current_level_style = style;
            $('#game_level').html('');
            _ref1 = temp.children('div, img, p, h1');
            for (_j = 0, _len1 = _ref1.length; _j < _len1; _j++) {
              div = _ref1[_j];
              $('#game_level').append($(div));
            }
            window.game.setup_level_physics();
            if (window.game.min === 'min') {
              return window.game.swap_resources();
            }
          });
        });
      },
      insert_player: function() {
        var pel;
        if (this.player) {
          this.player.element.detach();
        }
        pel = $('<div id="player" class="player"><div class="anim"></div></div>');
        $('#game_entities').append(pel);
        pel.css({
          left: 650,
          top: 230
        });
        this.player = new Player(pel[0], 1);
        return this.dynamic_objects.push(this.player);
      },
      contact_add: function(point) {
        var ab;
        ab = window.game.get_contact_entities(point);
        if (ab[0].dynamic) {
          ab[0].contact_add(ab[1], point);
        }
        if (ab[1].dynamic) {
          return ab[1].contact_add(ab[0], point);
        }
      },
      contact_begin: function(point) {
        var ab;
        ab = window.game.get_contact_entities(point);
        if (ab[0].dynamic) {
          ab[0].contact_begin(ab[1], point);
        }
        if (ab[1].dynamic) {
          return ab[1].contact_begin(ab[0], point);
        }
      },
      contact_persist: function(point) {
        var ab;
        ab = window.game.get_contact_entities(point);
        if (ab[0].dynamic) {
          ab[0].contact_persist(ab[1], point);
        }
        if (ab[1].dynamic) {
          return ab[1].contact_persist(ab[0], point);
        }
      },
      contact_remove: function(point) {
        var ab;
        ab = window.game.get_contact_entities(point);
        if (ab[0].dynamic) {
          ab[0].contact_remove(ab[1], point);
        }
        if (ab[1].dynamic) {
          return ab[1].contact_remove(ab[0], point);
        }
      },
      get_contact_entities: function(point) {
        var A, B;
        A = point.m_fixtureA.m_body.GetUserData();
        B = point.m_fixtureB.m_body.GetUserData();
        return [A, B];
      },
      setup_level_physics: function() {
        var b2AABB, b2Body, b2BodyDef, b2CircleShape, b2DebugDraw, b2Fixture, b2FixtureDef, b2MassData, b2MouseJointDef, b2PolygonShape, b2Vec2, b2World, debugDraw, div, entity, n, world, _i, _len, _ref;
        b2Vec2 = Box2D.Common.Math.b2Vec2;
        b2AABB = Box2D.Collision.b2AABB;
        b2BodyDef = Box2D.Dynamics.b2BodyDef;
        b2Body = Box2D.Dynamics.b2Body;
        b2FixtureDef = Box2D.Dynamics.b2FixtureDef;
        b2Fixture = Box2D.Dynamics.b2Fixture;
        b2World = Box2D.Dynamics.b2World;
        b2MassData = Box2D.Collision.Shapes.b2MassData;
        b2PolygonShape = Box2D.Collision.Shapes.b2PolygonShape;
        b2CircleShape = Box2D.Collision.Shapes.b2CircleShape;
        b2DebugDraw = Box2D.Dynamics.b2DebugDraw;
        b2MouseJointDef = Box2D.Dynamics.Joints.b2MouseJointDef;
        this.box2Dworld = new b2World(new b2Vec2(0, 20), true);
        world = this.box2Dworld;
        this.ContactListener = new Box2D.Dynamics.b2ContactListener();
        console.log(this.ContactListener);
        this.ContactListener.Add = this.contact_add;
        this.ContactListener.BeginContact = this.contact_begin;
        this.ContactListener.Persist = this.contact_persist;
        this.ContactListener.EndContact = this.contact_remove;
        this.box2Dworld.SetContactListener(this.ContactListener);
        console.log(this.ContactListener);
        _ref = $('#game_level').children();
        for (_i = 0, _len = _ref.length; _i < _len; _i++) {
          div = _ref[_i];
          if ($(div).hasClass('nocollide')) {
            n = 0;
          } else {
            entity = new Entity(div);
            if ($(div).hasClass('dynamic')) {
              this.dynamic_objects.push(entity);
              $(div).detach();
              $('#game_entities').append($(div));
            } else {
              this.static_objects.push(entity);
            }
          }
        }
        this.insert_player();
        if (this.debugdraw) {
          debugDraw = new b2DebugDraw();
          debugDraw.SetSprite(document.getElementById("game_area").getContext("2d"));
          debugDraw.SetDrawScale(this.scale);
          debugDraw.SetFillAlpha(0.5);
          debugDraw.SetLineThickness(1.0);
          debugDraw.SetFlags(b2DebugDraw.e_shapeBit | b2DebugDraw.e_jointBit);
          this.box2Dworld.SetDebugDraw(debugDraw);
          return world.DrawDebugData();
        }
      },
      create_body: function(x, y, w, h, angle, dynamic) {
        var b2AABB, b2Body, b2BodyDef, b2Fixture, b2FixtureDef, b2PolygonShape, bodyDef, fixDef;
        if (angle == null) {
          angle = 0;
        }
        if (dynamic == null) {
          dynamic = 0;
        }
        console.log('creating physics body');
        b2FixtureDef = Box2D.Dynamics.b2FixtureDef;
        b2Fixture = Box2D.Dynamics.b2Fixture;
        b2AABB = Box2D.Collision.b2AABB;
        b2BodyDef = Box2D.Dynamics.b2BodyDef;
        b2Body = Box2D.Dynamics.b2Body;
        b2PolygonShape = Box2D.Collision.Shapes.b2PolygonShape;
        fixDef = new b2FixtureDef;
        fixDef.density = 1.0;
        fixDef.friction = 1.2;
        fixDef.restitution = 0.2;
        bodyDef = new b2BodyDef;
        if (!dynamic) {
          bodyDef.type = b2Body.b2_staticBody;
        } else {
          bodyDef.type = b2Body.b2_dynamicBody;
        }
        fixDef.shape = new b2PolygonShape;
        fixDef.shape.SetAsBox(w / this.scale, h / this.scale);
        bodyDef.angle = angle;
        bodyDef.position.Set(x / this.scale, y / this.scale);
        return this.box2Dworld.CreateBody(bodyDef).CreateFixture(fixDef);
      },
      get_element_rotation: function(obj) {
        var a, b, matrix, radians, values;
        obj = $(obj);
        matrix = obj.css("-webkit-transform") || obj.css("-moz-transform") || obj.css("-ms-transform") || obj.css("-o-transform") || obj.css("transform");
        if (matrix !== "none") {
          values = matrix.split("(")[1].split(")")[0].split(",");
          a = values[0];
          b = values[1];
          return radians = Math.atan2(b, a);
        } else {
          return radians = 0;
        }
      },
      update_world: function() {
        var entity, _i, _j, _len, _len1, _ref, _ref1;
        requestAnimationFrame(window.game.update_world);
        _ref = window.game.dynamic_objects;
        for (_i = 0, _len = _ref.length; _i < _len; _i++) {
          entity = _ref[_i];
          entity.pre_step_update();
        }
        window.game.box2Dworld.Step(1 / 30, 20, 20);
        if (window.game.debugdraw) {
          window.game.box2Dworld.DrawDebugData();
        }
        window.game.box2Dworld.ClearForces();
        _ref1 = window.game.dynamic_objects;
        for (_j = 0, _len1 = _ref1.length; _j < _len1; _j++) {
          entity = _ref1[_j];
          entity.update();
        }
        return window.game.move_layers();
      },
      getBodyAtPoint: function(x, y) {
        var aabb, b2AABB, b2Vec2, entities, getBodyCB, selectedBody;
        b2Vec2 = Box2D.Common.Math.b2Vec2;
        b2AABB = Box2D.Collision.b2AABB;
        entities = [];
        getBodyCB = function(fixture) {
          if (fixture.m_body.m_userData) {
            entities.push(fixture.m_body.m_userData);
            return true;
          }
          return true;
        };
        window.mousePVec = new b2Vec2(x, y);
        aabb = new b2AABB();
        aabb.lowerBound.Set(x - 0.001, y - 0.001);
        aabb.upperBound.Set(x + 0.001, y + 0.001);
        selectedBody = null;
        this.box2Dworld.QueryAABB(getBodyCB, aabb);
        return entities;
      },
      move_layers: function() {
        var g_o, i, layer, x, y, _i, _len, _ref;
        if (this.player) {
          x = this.player.x * this.scale - this.game_w / 2;
          y = this.player.y * this.scale - this.game_h / 2;
          g_o = $('#game_level').offset();
          _ref = $('#background').children();
          for (i = _i = 0, _len = _ref.length; _i < _len; i = ++_i) {
            layer = _ref[i];
            $(layer).css({
              'left': (-x / i) * .4,
              'top': (-y / i) * .4
            });
          }
          return $('#game_level, #game_area, #game_entities').css({
            'left': -x,
            'top': -y
          });
        }
      }
    };
    window.game.init();
    window.game.load_level('level03.html');
    return window.game.update_world();
  });

}).call(this);
